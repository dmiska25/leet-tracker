[
  {
    "slug": "two-sum",
    "title": "Two Sum",
    "timestamp": 1745646660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n        return []",
    "timeUsed": 720,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 3,
        "time_complexity": "O(n)",
        "space_complexity": "O(n)",
        "comments": "Good use of hash map for optimal time complexity. Solved efficiently."
      },
      "code_quality": {
        "readability": 4,
        "correctness": 5,
        "maintainability": 4,
        "comments": "Clean implementation with descriptive variable names. Could benefit from comments."
      },
      "summary": {
        "final_score": 85,
        "comments": "Solid solution demonstrating understanding of hash tables. Well-optimized approach."
      }
    }
  },
  {
    "slug": "reverse-linked-list",
    "title": "Reverse Linked List",
    "timestamp": 1745676660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        current = head\n        while current:\n            next_temp = current.next\n            current.next = prev\n            prev = current\n            current = next_temp\n        return prev",
    "timeUsed": 480,
    "usedHints": "none"
  },
  {
    "slug": "best-time-to-buy-and-sell-stock",
    "title": "Best Time to Buy and Sell Stock",
    "timestamp": 1745706660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        return max_profit",
    "timeUsed": 600,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 4,
        "time_complexity": "O(n)",
        "space_complexity": "O(1)",
        "comments": "Excellent single-pass solution with optimal space usage."
      },
      "code_quality": {
        "readability": 5,
        "correctness": 5,
        "maintainability": 5,
        "comments": "Very clean and readable code with proper variable naming."
      },
      "summary": {
        "final_score": 92,
        "comments": "Outstanding solution showing mastery of dynamic programming concepts."
      }
    }
  },
  {
    "slug": "merge-intervals",
    "title": "Merge Intervals",
    "timestamp": 1745736660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        if not intervals:\n            return []\n        \n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n        \n        for current in intervals[1:]:\n            if current[0] <= merged[-1][1]:\n                merged[-1][1] = max(merged[-1][1], current[1])\n            else:\n                merged.append(current)\n        \n        return merged",
    "timeUsed": 900,
    "usedHints": "leetcode_hint"
  },
  {
    "slug": "3sum",
    "title": "3Sum",
    "timestamp": 1745766660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n        \n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total < 0:\n                    left += 1\n                elif total > 0:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n        \n        return result",
    "timeUsed": 1440,
    "usedHints": "solution_peek",
    "feedback": {
      "performance": {
        "time_to_solve": 2,
        "time_complexity": "O(nÂ²)",
        "space_complexity": "O(1)",
        "comments": "Used hints but implemented correctly. Two-pointer approach is optimal."
      },
      "code_quality": {
        "readability": 3,
        "correctness": 5,
        "maintainability": 3,
        "comments": "Correct implementation but could be more readable with better variable names."
      },
      "summary": {
        "final_score": 72,
        "comments": "Good understanding shown despite needing hints. Complex problem handled well."
      }
    }
  },
  {
    "slug": "climbing-stairs",
    "title": "Climbing Stairs",
    "timestamp": 1745796660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 2:\n            return n\n        \n        prev2, prev1 = 1, 2\n        for i in range(3, n + 1):\n            current = prev1 + prev2\n            prev2 = prev1\n            prev1 = current\n        \n        return prev1",
    "timeUsed": 300,
    "usedHints": "none"
  },
  {
    "slug": "longest-substring-without-repeating-characters",
    "title": "Longest Substring Without Repeating Characters",
    "timestamp": 1745826660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_map = {}\n        left = 0\n        max_length = 0\n        \n        for right in range(len(s)):\n            if s[right] in char_map and char_map[s[right]] >= left:\n                left = char_map[s[right]] + 1\n            char_map[s[right]] = right\n            max_length = max(max_length, right - left + 1)\n        \n        return max_length",
    "timeUsed": 840,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 3,
        "time_complexity": "O(n)",
        "space_complexity": "O(min(m,n))",
        "comments": "Efficient sliding window approach with optimal time complexity."
      },
      "code_quality": {
        "readability": 4,
        "correctness": 5,
        "maintainability": 4,
        "comments": "Clean sliding window implementation. Good variable naming."
      },
      "summary": {
        "final_score": 88,
        "comments": "Excellent understanding of sliding window technique. Well-implemented solution."
      }
    }
  },
  {
    "slug": "binary-tree-level-order-traversal",
    "title": "Binary Tree Level Order Traversal",
    "timestamp": 1745856660,
    "status": "Accepted",
    "lang": "python3",
    "code": "from collections import deque\n\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return []\n        \n        result = []\n        queue = deque([root])\n        \n        while queue:\n            level_size = len(queue)\n            level_nodes = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                level_nodes.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(level_nodes)\n        \n        return result",
    "timeUsed": 660,
    "usedHints": "none"
  },
  {
    "slug": "valid-parentheses",
    "title": "Valid Parentheses",
    "timestamp": 1745886660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        mapping = {')': '(', '}': '{', ']': '['}\n        \n        for char in s:\n            if char in mapping:\n                if not stack or stack.pop() != mapping[char]:\n                    return False\n            else:\n                stack.append(char)\n        \n        return not stack",
    "timeUsed": 360,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 4,
        "time_complexity": "O(n)",
        "space_complexity": "O(n)",
        "comments": "Classic stack problem solved efficiently. Good understanding of data structures."
      },
      "code_quality": {
        "readability": 5,
        "correctness": 5,
        "maintainability": 5,
        "comments": "Excellent code quality with clear logic and proper use of dictionary mapping."
      },
      "summary": {
        "final_score": 95,
        "comments": "Perfect implementation demonstrating mastery of stack data structure."
      }
    }
  },
  {
    "slug": "coin-change",
    "title": "Coin Change",
    "timestamp": 1745916660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        \n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n        \n        return dp[amount] if dp[amount] != float('inf') else -1",
    "timeUsed": 1200,
    "usedHints": "leetcode_hint"
  },
  {
    "slug": "maximum-subarray",
    "title": "Maximum Subarray",
    "timestamp": 1745946660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        current_sum = max_sum = nums[0]\n        \n        for num in nums[1:]:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum",
    "timeUsed": 420,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 4,
        "time_complexity": "O(n)",
        "space_complexity": "O(1)",
        "comments": "Kadane's algorithm implemented perfectly. Optimal solution."
      },
      "code_quality": {
        "readability": 5,
        "correctness": 5,
        "maintainability": 5,
        "comments": "Concise and elegant implementation of classic algorithm."
      },
      "summary": {
        "final_score": 94,
        "comments": "Excellent demonstration of dynamic programming principles."
      }
    }
  },
  {
    "slug": "palindrome-number",
    "title": "Palindrome Number",
    "timestamp": 1745976660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n        \n        original = x\n        reversed_num = 0\n        \n        while x > 0:\n            reversed_num = reversed_num * 10 + x % 10\n            x //= 10\n        \n        return original == reversed_num",
    "timeUsed": 240,
    "usedHints": "none"
  },
  {
    "slug": "valid-anagram",
    "title": "Valid Anagram",
    "timestamp": 1746006660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        char_count = {}\n        \n        for char in s:\n            char_count[char] = char_count.get(char, 0) + 1\n        \n        for char in t:\n            if char not in char_count:\n                return False\n            char_count[char] -= 1\n            if char_count[char] == 0:\n                del char_count[char]\n        \n        return len(char_count) == 0",
    "timeUsed": 300,
    "usedHints": "none"
  },
  {
    "slug": "contains-duplicate",
    "title": "Contains Duplicate",
    "timestamp": 1746036660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False",
    "timeUsed": 180,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 5,
        "time_complexity": "O(n)",
        "space_complexity": "O(n)",
        "comments": "Very quick solve with optimal approach using set data structure."
      },
      "code_quality": {
        "readability": 5,
        "correctness": 5,
        "maintainability": 5,
        "comments": "Simple, clean, and efficient implementation."
      },
      "summary": {
        "final_score": 96,
        "comments": "Perfect solution demonstrating efficient use of hash set."
      }
    }
  },
  {
    "slug": "maximum-depth-of-binary-tree",
    "title": "Maximum Depth of Binary Tree",
    "timestamp": 1746066660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        left_depth = self.maxDepth(root.left)\n        right_depth = self.maxDepth(root.right)\n        \n        return 1 + max(left_depth, right_depth)",
    "timeUsed": 240,
    "usedHints": "none"
  },
  {
    "slug": "invert-binary-tree",
    "title": "Invert Binary Tree",
    "timestamp": 1746096660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        \n        root.left, root.right = root.right, root.left\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root",
    "timeUsed": 180,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 5,
        "time_complexity": "O(n)",
        "space_complexity": "O(h)",
        "comments": "Quick and elegant recursive solution. Good understanding of tree traversal."
      },
      "code_quality": {
        "readability": 5,
        "correctness": 5,
        "maintainability": 5,
        "comments": "Clean recursive implementation with proper base case handling."
      },
      "summary": {
        "final_score": 93,
        "comments": "Excellent solution showing strong grasp of recursion and tree manipulation."
      }
    }
  },
  {
    "slug": "valid-palindrome",
    "title": "Valid Palindrome",
    "timestamp": 1746126660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        left, right = 0, len(s) - 1\n        \n        while left < right:\n            while left < right and not s[left].isalnum():\n                left += 1\n            while left < right and not s[right].isalnum():\n                right -= 1\n            \n            if s[left].lower() != s[right].lower():\n                return False\n            \n            left += 1\n            right -= 1\n        \n        return True",
    "timeUsed": 480,
    "usedHints": "none"
  },
  {
    "slug": "merge-two-sorted-lists",
    "title": "Merge Two Sorted Lists",
    "timestamp": 1746156660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0)\n        current = dummy\n        \n        while list1 and list2:\n            if list1.val <= list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n        \n        current.next = list1 or list2\n        \n        return dummy.next",
    "timeUsed": 420,
    "usedHints": "none"
  },
  {
    "slug": "binary-search",
    "title": "Binary Search",
    "timestamp": 1746186660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1",
    "timeUsed": 300,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 4,
        "time_complexity": "O(log n)",
        "space_complexity": "O(1)",
        "comments": "Classic binary search implemented correctly with optimal complexity."
      },
      "code_quality": {
        "readability": 5,
        "correctness": 5,
        "maintainability": 5,
        "comments": "Textbook implementation of binary search. Very clean code."
      },
      "summary": {
        "final_score": 90,
        "comments": "Perfect understanding of binary search algorithm fundamentals."
      }
    }
  },
  {
    "slug": "fibonacci-number",
    "title": "Fibonacci Number",
    "timestamp": 1746216660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def fib(self, n: int) -> int:\n        if n <= 1:\n            return n\n        \n        a, b = 0, 1\n        for i in range(2, n + 1):\n            a, b = b, a + b\n        \n        return b",
    "timeUsed": 240,
    "usedHints": "none"
  },
  {
    "slug": "majority-element",
    "title": "Majority Element",
    "timestamp": 1746246660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate",
    "timeUsed": 600,
    "usedHints": "gpt_help"
  },
  {
    "slug": "symmetric-tree",
    "title": "Symmetric Tree",
    "timestamp": 1746276660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        def isMirror(left: Optional[TreeNode], right: Optional[TreeNode]) -> bool:\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return (left.val == right.val and \n                    isMirror(left.left, right.right) and \n                    isMirror(left.right, right.left))\n        \n        return isMirror(root.left, root.right) if root else True",
    "timeUsed": 720,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 3,
        "time_complexity": "O(n)",
        "space_complexity": "O(h)",
        "comments": "Good recursive approach with helper function. Efficient solution."
      },
      "code_quality": {
        "readability": 4,
        "correctness": 5,
        "maintainability": 4,
        "comments": "Well-structured code with clear helper function. Good edge case handling."
      },
      "summary": {
        "final_score": 87,
        "comments": "Strong understanding of tree recursion and symmetric properties."
      }
    }
  },
  {
    "slug": "merge-sorted-array",
    "title": "Merge Sorted Array",
    "timestamp": 1746306660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        i, j, k = m - 1, n - 1, m + n - 1\n        \n        while j >= 0:\n            if i >= 0 and nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1",
    "timeUsed": 540,
    "usedHints": "leetcode_hint"
  },
  {
    "slug": "climbing-stairs",
    "title": "Climbing Stairs",
    "timestamp": 1746336660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 2:\n            return n\n        \n        prev2, prev1 = 1, 2\n        for i in range(3, n + 1):\n            current = prev1 + prev2\n            prev2 = prev1\n            prev1 = current\n        \n        return prev1",
    "timeUsed": 300,
    "usedHints": "none"
  },
  {
    "slug": "best-time-to-buy-and-sell-stock-ii",
    "title": "Best Time to Buy and Sell Stock II",
    "timestamp": 1746366660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        total_profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i-1]:\n                total_profit += prices[i] - prices[i-1]\n        return total_profit",
    "timeUsed": 360,
    "usedHints": "none"
  },
  {
    "slug": "single-number",
    "title": "Single Number",
    "timestamp": 1746396660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        result = 0\n        for num in nums:\n            result ^= num\n        return result",
    "timeUsed": 420,
    "usedHints": "solution_peek",
    "feedback": {
      "performance": {
        "time_to_solve": 3,
        "time_complexity": "O(n)",
        "space_complexity": "O(1)",
        "comments": "Elegant bit manipulation solution. Needed hints but understood the concept."
      },
      "code_quality": {
        "readability": 4,
        "correctness": 5,
        "maintainability": 4,
        "comments": "Very concise implementation using XOR properties effectively."
      },
      "summary": {
        "final_score": 78,
        "comments": "Good learning moment for bit manipulation techniques."
      }
    }
  },
  {
    "slug": "linked-list-cycle",
    "title": "Linked List Cycle",
    "timestamp": 1746426660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        if not head or not head.next:\n            return False\n        \n        slow = head\n        fast = head.next\n        \n        while fast and fast.next:\n            if slow == fast:\n                return True\n            slow = slow.next\n            fast = fast.next.next\n        \n        return False",
    "timeUsed": 480,
    "usedHints": "none"
  },
  {
    "slug": "intersection-of-two-linked-lists",
    "title": "Intersection of Two Linked Lists",
    "timestamp": 1746456660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if not headA or not headB:\n            return None\n        \n        pA, pB = headA, headB\n        \n        while pA != pB:\n            pA = pA.next if pA else headB\n            pB = pB.next if pB else headA\n        \n        return pA",
    "timeUsed": 900,
    "usedHints": "gpt_help"
  },
  {
    "slug": "remove-duplicates-from-sorted-array",
    "title": "Remove Duplicates from Sorted Array",
    "timestamp": 1746486660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1",
    "timeUsed": 360,
    "usedHints": "none"
  },
  {
    "slug": "move-zeroes",
    "title": "Move Zeroes",
    "timestamp": 1746516660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        left = 0\n        for right in range(len(nums)):\n            if nums[right] != 0:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1",
    "timeUsed": 300,
    "usedHints": "none"
  },
  {
    "slug": "two-sum-ii-input-array-is-sorted",
    "title": "Two Sum II - Input Array Is Sorted",
    "timestamp": 1746546660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        left, right = 0, len(numbers) - 1\n        \n        while left < right:\n            current_sum = numbers[left] + numbers[right]\n            if current_sum == target:\n                return [left + 1, right + 1]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return []",
    "timeUsed": 240,
    "usedHints": "none"
  },
  {
    "slug": "minimum-depth-of-binary-tree",
    "title": "Minimum Depth of Binary Tree",
    "timestamp": 1746576660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        left_depth = float('inf') if not root.left else self.minDepth(root.left)\n        right_depth = float('inf') if not root.right else self.minDepth(root.right)\n        \n        return 1 + min(left_depth, right_depth)",
    "timeUsed": 600,
    "usedHints": "none"
  },
  {
    "slug": "path-sum",
    "title": "Path Sum",
    "timestamp": 1746606660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return root.val == targetSum\n        \n        return (self.hasPathSum(root.left, targetSum - root.val) or \n                self.hasPathSum(root.right, targetSum - root.val))",
    "timeUsed": 420,
    "usedHints": "none"
  },
  {
    "slug": "same-tree",
    "title": "Same Tree",
    "timestamp": 1746636660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return (p.val == q.val and \n                self.isSameTree(p.left, q.left) and \n                self.isSameTree(p.right, q.right))",
    "timeUsed": 180,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 3,
        "time_complexity": "O(n)",
        "space_complexity": "O(h)",
        "comments": "Good recursive solution. Efficient and clear logic."
      },
      "code_quality": {
        "readability": 5,
        "correctness": 5,
        "maintainability": 5,
        "comments": "Well-structured code with clear base cases."
      },
      "summary": {
        "final_score": 78,
        "comments": "Excellent understanding of tree structure and recursion."
      }
    }
  },
  {
    "slug": "maximum-binary-tree",
    "title": "Maximum Binary Tree",
    "timestamp": 1746666660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:\n        if not nums:\n            return None\n        \n        max_val = max(nums)\n        max_idx = nums.index(max_val)\n        \n        root = TreeNode(max_val)\n        root.left = self.constructMaximumBinaryTree(nums[:max_idx])\n        root.right = self.constructMaximumBinaryTree(nums[max_idx + 1:])\n        \n        return root",
    "timeUsed": 720,
    "usedHints": "none"
  },
  {
    "slug": "lowest-common-ancestor-of-a-binary-search-tree",
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "timestamp": 1746696660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if p.val < root.val and q.val < root.val:\n                root = root.left\n            elif p.val > root.val and q.val > root.val:\n                root = root.right\n            else:\n                return root\n        return None",
    "timeUsed": 540,
    "usedHints": "none",
    "codingJourney": {
      "snapshots": [
        {
          "timestamp": 1746696120000,
          "fullCode": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        # TODO: implement\n        pass",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746696174000,
          "fullCode": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        # TODO: implement\n        pass",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746696228000,
          "fullCode": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        # TODO: implement\n        pass",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746696282000,
          "fullCode": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if p.val < root.val and q.val < root.val:\n                root = root.left\n        # TODO: complete",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746696336000,
          "fullCode": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if p.val < root.val and q.val < root.val:\n                root = root.left\n        # TODO: complete",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746696390000,
          "fullCode": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if p.val < root.val and q.val < root.val:\n                root = root.left\n            elif p.val > root.val and q.val > root.val:\n                root = root.right\n            else:\n        # TODO: return result",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746696444000,
          "fullCode": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if p.val < root.val and q.val < root.val:\n                root = root.left\n            elif p.val > root.val and q.val > root.val:\n                root = root.right\n            else:\n        # TODO: return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746696498000,
          "fullCode": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if p.val < root.val and q.val < root.val:\n                root = root.left\n            elif p.val > root.val and q.val > root.val:\n                root = root.right\n            else:\n        # TODO: return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746696552000,
          "fullCode": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if p.val < root.val and q.val < root.val:\n                root = root.left\n            elif p.val > root.val and q.val > root.val:\n                root = root.right\n            else:\n                return root\n        return None",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746696606000,
          "fullCode": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if p.val < root.val and q.val < root.val:\n                root = root.left\n            elif p.val > root.val and q.val > root.val:\n                root = root.right\n            else:\n                return root\n        return None",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746696660000,
          "fullCode": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if p.val < root.val and q.val < root.val:\n                root = root.left\n            elif p.val > root.val and q.val > root.val:\n                root = root.right\n            else:\n                return root\n        return None",
          "isCheckpoint": true
        }
      ],
      "snapshotCount": 11,
      "totalCodingTime": 540000,
      "firstSnapshot": 1746696120000,
      "lastSnapshot": 1746696660000,
      "hasDetailedJourney": true
    },
    "runEvents": {
      "count": 4,
      "firstRun": 1746696187500,
      "lastRun": 1746696592500,
      "hasDetailedRuns": true,
      "runs": [
        {
          "id": "run_1758155029479_0",
          "startedAt": 1746696187500,
          "statusMsg": "Wrong Answer",
          "totalCorrect": 46,
          "totalTestcases": 75,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        # TODO: implement\n        pass",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029479_1",
          "startedAt": 1746696322500,
          "statusMsg": "Time Limit Exceeded",
          "totalCorrect": 44,
          "totalTestcases": 64,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if p.val < root.val and q.val < root.val:\n                root = root.left\n        # TODO: complete",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029479_2",
          "startedAt": 1746696457500,
          "statusMsg": "Time Limit Exceeded",
          "totalCorrect": 48,
          "totalTestcases": 63,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if p.val < root.val and q.val < root.val:\n                root = root.left\n            elif p.val > root.val and q.val > root.val:\n                root = root.right\n            else:\n        # TODO: return result",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029479_3",
          "startedAt": 1746696592500,
          "statusMsg": "Accepted",
          "totalCorrect": 67,
          "totalTestcases": 71,
          "runtimeError": null,
          "lastTestcase": null,
          "code": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root:\n            if p.val < root.val and q.val < root.val:\n                root = root.left\n            elif p.val > root.val and q.val > root.val:\n                root = root.right\n            else:\n                return root\n        return None",
          "compareResult": null,
          "runtime": 140,
          "memory": 10
        }
      ],
      "_window": {
        "startMs": 1746696120000,
        "endMs": 1746696660000
      }
    },
    "feedback": {
      "performance": {
        "time_to_solve": 2,
        "time_complexity": "O(h)",
        "space_complexity": "O(1)",
        "comments": "Slow start with 9min of TODO code, then rushed implementation causing TLE bugs. Timeline shows multiple failed runs before fixing the missing conditions."
      },
      "code_quality": {
        "readability": 4,
        "correctness": 5,
        "maintainability": 4,
        "comments": "Final solution is clean and correct. Code evolution shows good BST property understanding after initial struggle."
      },
      "summary": {
        "final_score": 72,
        "comments": "Scores: time=2, correctness=5, readability=4, maintainability=4, process=2, algorithmic_efficiency=5, penalties=-1. Timeline reveals planning issues: start coding sooner, test incrementally. The 3 failed runs could be avoided with better edge case consideration."
      }
    }
  },
  {
    "slug": "binary-tree-inorder-traversal",
    "title": "Binary Tree Inorder Traversal",
    "timestamp": 1746726660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def inorder(node):\n            if node:\n                inorder(node.left)\n                result.append(node.val)\n                inorder(node.right)\n        \n        inorder(root)\n        return result",
    "timeUsed": 300,
    "usedHints": "none",
    "codingJourney": {
      "snapshots": [
        {
          "timestamp": 1746726360000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        # TODO: implement\n        return []",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746726385000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        # TODO: implement\n        return []",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746726410000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        # TODO: implement\n        return []",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746726435000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        # TODO: add traversal logic\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746726460000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        # TODO: add traversal logic\n        return result",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746726485000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746726510000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746726535000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746726560000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746726585000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746726610000,
          "fullCode": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def inorder(node):\n            if node:\n                inorder(node.left)\n                result.append(node.val)\n                inorder(node.right)\n        \n        inorder(root)\n        return result",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746726635000,
          "fullCode": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def inorder(node):\n            if node:\n                inorder(node.left)\n                result.append(node.val)\n                inorder(node.right)\n        \n        inorder(root)\n        return result",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746726660000,
          "fullCode": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def inorder(node):\n            if node:\n                inorder(node.left)\n                result.append(node.val)\n                inorder(node.right)\n        \n        inorder(root)\n        return result",
          "isCheckpoint": true
        }
      ],
      "snapshotCount": 13,
      "totalCodingTime": 300000,
      "firstSnapshot": 1746726360000,
      "lastSnapshot": 1746726660000,
      "hasDetailedJourney": true
    },
    "runEvents": {
      "count": 5,
      "firstRun": 1746726390000,
      "lastRun": 1746726630000,
      "hasDetailedRuns": true,
      "runs": [
        {
          "id": "run_1758155029478_0",
          "startedAt": 1746726390000,
          "statusMsg": "Time Limit Exceeded",
          "totalCorrect": 28,
          "totalTestcases": 76,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def preorderTraversal(self, root):\n        # TODO: implement\n        return []",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_1",
          "startedAt": 1746726450000,
          "statusMsg": "Wrong Answer",
          "totalCorrect": 20,
          "totalTestcases": 60,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        # TODO: add traversal logic\n        return result",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_2",
          "startedAt": 1746726510000,
          "statusMsg": "Runtime Error",
          "totalCorrect": 58,
          "totalTestcases": 63,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n        \n        preorder(root)\n        return result",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_3",
          "startedAt": 1746726570000,
          "statusMsg": "Time Limit Exceeded",
          "totalCorrect": 31,
          "totalTestcases": 74,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_4",
          "startedAt": 1746726630000,
          "statusMsg": "Accepted",
          "totalCorrect": 64,
          "totalTestcases": 74,
          "runtimeError": null,
          "lastTestcase": null,
          "code": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def inorder(node):\n            if node:\n                inorder(node.left)\n                result.append(node.val)\n                inorder(node.right)\n        \n        inorder(root)\n        return result",
          "compareResult": null,
          "runtime": 99,
          "memory": 13
        }
      ],
      "_window": {
        "startMs": 1746726360000,
        "endMs": 1746726660000
      }
    },
    "feedback": {
      "performance": {
        "time_to_solve": 3,
        "time_complexity": "O(n)",
        "space_complexity": "O(h)",
        "comments": "Good 5min solve but timeline shows confusion between pre/in/postorder initially. Multiple TLE runs suggest missing base cases or infinite recursion in early attempts."
      },
      "code_quality": {
        "readability": 5,
        "correctness": 5,
        "maintainability": 5,
        "comments": "Clean recursive solution with proper helper function. Timeline evolution shows good debugging process from broken recursion to correct implementation."
      },
      "summary": {
        "final_score": 82,
        "comments": "Scores: time=3, correctness=5, readability=5, maintainability=5, process=4, algorithmic_efficiency=5. Timeline insight: practice distinguishing traversal types quickly, add base case checks first to avoid TLE iterations."
      }
    }
  },
  {
    "slug": "binary-tree-postorder-traversal",
    "title": "Binary Tree Postorder Traversal",
    "timestamp": 1746756660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def postorder(node):\n            if node:\n                postorder(node.left)\n                postorder(node.right)\n                result.append(node.val)\n        \n        postorder(root)\n        return result",
    "timeUsed": 300,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 2,
        "time_complexity": "O(n)",
        "space_complexity": "O(h)",
        "comments": "Good 5min solve but timeline reveals function name confusion. Spent most time implementing preorderTraversal logic, then had to pivot to correct postorder semantics at the end."
      },
      "code_quality": {
        "readability": 4,
        "correctness": 5,
        "maintainability": 4,
        "comments": "Final solution is correct and clean. Timeline shows methodical development but function name mixup caused 3 failed runs before realizing traversal order issue."
      },
      "summary": {
        "final_score": 74,
        "comments": "Scores: time=2, correctness=5, readability=4, maintainability=4, process=2, algorithmic_efficiency=5, penalties=-1. Timeline insight: read problem statement carefully - the entire timeline shows preorder implementation until final correction to postorder."
      }
    },
    "codingJourney": {
      "snapshots": [
        {
          "timestamp": 1746756360000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        # TODO: implement\n        return []",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746756397500,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        # TODO: implement\n        return []",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746756435000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        # TODO: add traversal logic\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746756472500,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        # TODO: add traversal logic\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746756510000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746756547500,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746756585000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746756622500,
          "fullCode": "class Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def postorder(node):\n            if node:\n                postorder(node.left)\n                postorder(node.right)\n                result.append(node.val)\n        \n        postorder(root)\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746756660000,
          "fullCode": "class Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def postorder(node):\n            if node:\n                postorder(node.left)\n                postorder(node.right)\n                result.append(node.val)\n        \n        postorder(root)\n        return result",
          "isCheckpoint": true
        }
      ],
      "snapshotCount": 9,
      "totalCodingTime": 300000,
      "firstSnapshot": 1746756360000,
      "lastSnapshot": 1746756660000,
      "hasDetailedJourney": true
    },
    "runEvents": {
      "count": 4,
      "firstRun": 1746756397500,
      "lastRun": 1746756622500,
      "hasDetailedRuns": true,
      "runs": [
        {
          "id": "run_1758155029478_0",
          "startedAt": 1746756397500,
          "statusMsg": "Runtime Error",
          "totalCorrect": 41,
          "totalTestcases": 78,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def preorderTraversal(self, root):\n        # TODO: implement\n        return []",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_1",
          "startedAt": 1746756472500,
          "statusMsg": "Runtime Error",
          "totalCorrect": 36,
          "totalTestcases": 70,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        # TODO: add traversal logic\n        return result",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_2",
          "startedAt": 1746756547500,
          "statusMsg": "Wrong Answer",
          "totalCorrect": 27,
          "totalTestcases": 71,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_3",
          "startedAt": 1746756622500,
          "statusMsg": "Accepted",
          "totalCorrect": 69,
          "totalTestcases": 78,
          "runtimeError": null,
          "lastTestcase": null,
          "code": "class Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def postorder(node):\n            if node:\n                postorder(node.left)\n                postorder(node.right)\n                result.append(node.val)\n        \n        postorder(root)\n        return result",
          "compareResult": null,
          "runtime": 111,
          "memory": 12
        }
      ],
      "_window": {
        "startMs": 1746756360000,
        "endMs": 1746756660000
      }
    }
  },
  {
    "slug": "binary-tree-preorder-traversal",
    "title": "Binary Tree Preorder Traversal",
    "timestamp": 1746786660,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
    "timeUsed": 300,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 3,
        "time_complexity": "O(n)",
        "space_complexity": "O(h)",
        "comments": "Solid 5min solve time but timeline shows incremental build-up. Early snapshots missing recursive calls, causing failed runs until complete implementation emerged."
      },
      "code_quality": {
        "readability": 4,
        "correctness": 5,
        "maintainability": 4,
        "comments": "Clean final solution with proper helper function. Timeline evolution shows methodical development: setup structure first, then add recursive logic step-by-step."
      },
      "summary": {
        "final_score": 81,
        "comments": "Scores: time=3, correctness=5, readability=4, maintainability=4, process=4, algorithmic_efficiency=5. Timeline insight: commit to full recursive structure earlier to avoid incomplete-logic runs. The 3 failed attempts show missing left/right calls in intermediate versions."
      }
    },
    "codingJourney": {
      "snapshots": [
        {
          "timestamp": 1746786360000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        # TODO: implement\n        return []",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746786390000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        # TODO: implement\n        return []",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746786420000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        # TODO: add traversal logic\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746786450000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        # TODO: add traversal logic\n        return result",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746786480000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746786510000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746786540000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746786570000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746786600000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746786630000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746786660000,
          "fullCode": "class Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "isCheckpoint": true
        }
      ],
      "snapshotCount": 11,
      "totalCodingTime": 300000,
      "firstSnapshot": 1746786360000,
      "lastSnapshot": 1746786660000,
      "hasDetailedJourney": true
    },
    "runEvents": {
      "count": 4,
      "firstRun": 1746786397500,
      "lastRun": 1746786622500,
      "hasDetailedRuns": true,
      "runs": [
        {
          "id": "run_1758155029478_0",
          "startedAt": 1746786397500,
          "statusMsg": "Runtime Error",
          "totalCorrect": 59,
          "totalTestcases": 77,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def preorderTraversal(self, root):\n        # TODO: implement\n        return []",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_1",
          "startedAt": 1746786472500,
          "statusMsg": "Wrong Answer",
          "totalCorrect": 28,
          "totalTestcases": 63,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        # TODO: add traversal logic\n        return result",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_2",
          "startedAt": 1746786547500,
          "statusMsg": "Wrong Answer",
          "totalCorrect": 20,
          "totalTestcases": 62,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def preorderTraversal(self, root):\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_3",
          "startedAt": 1746786622500,
          "statusMsg": "Accepted",
          "totalCorrect": 73,
          "totalTestcases": 62,
          "runtimeError": null,
          "lastTestcase": null,
          "code": "class Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        \n        def preorder(node):\n            if node:\n                result.append(node.val)\n                preorder(node.left)\n                preorder(node.right)\n        \n        preorder(root)\n        return result",
          "compareResult": null,
          "runtime": 91,
          "memory": 11
        }
      ],
      "_window": {
        "startMs": 1746786360000,
        "endMs": 1746786660000
      }
    }
  },
  {
    "slug": "implement-strstr",
    "title": "Implement strStr()",
    "timestamp": 1746878400,
    "status": "Accepted",
    "lang": "python3",
    "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n        \n        return -1",
    "timeUsed": 360,
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 3,
        "time_complexity": "O(n*m)",
        "space_complexity": "O(1)",
        "comments": "Good 6min solve but timeline shows classic off-by-one struggle. Initial implementation had range bounds error causing index out of bounds, fixed after multiple failed runs."
      },
      "code_quality": {
        "readability": 4,
        "correctness": 5,
        "maintainability": 4,
        "comments": "Final solution is clean and correct. Timeline evolution shows methodical debugging: identified range issue and applied proper bounds (len(haystack) - len(needle) + 1)."
      },
      "summary": {
        "final_score": 78,
        "comments": "Scores: time=3, correctness=5, readability=4, maintainability=4, process=3, algorithmic_efficiency=4. Timeline insight: watch for edge case testing - the multiple failed runs show bounds checking is critical for substring problems."
      }
    },
    "codingJourney": {
      "snapshots": [
        {
          "timestamp": 1746878040000,
          "fullCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        # TODO: implement\n        pass",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746878072727,
          "fullCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        # TODO: implement\n        pass",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746878105454,
          "fullCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        # TODO: implement\n        pass",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746878138181,
          "fullCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        # TODO: add logic",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746878170909,
          "fullCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        # TODO: add logic",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746878203636,
          "fullCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746878236363,
          "fullCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746878269090,
          "fullCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        # Fix bounds check\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n        return -1",
          "isCheckpoint": true
        },
        {
          "timestamp": 1746878301818,
          "fullCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        # Fix bounds check\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n        return -1",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746878334545,
          "fullCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n        \n        return -1",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746878367272,
          "fullCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n        \n        return -1",
          "isCheckpoint": false
        },
        {
          "timestamp": 1746878400000,
          "fullCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n        \n        return -1",
          "isCheckpoint": true
        }
      ],
      "snapshotCount": 12,
      "totalCodingTime": 360000,
      "firstSnapshot": 1746878040000,
      "lastSnapshot": 1746878400000,
      "hasDetailedJourney": true
    },
    "runEvents": {
      "count": 5,
      "firstRun": 1746878076000,
      "lastRun": 1746878364000,
      "hasDetailedRuns": true,
      "runs": [
        {
          "id": "run_1758155029478_0",
          "startedAt": 1746878076000,
          "statusMsg": "Time Limit Exceeded",
          "totalCorrect": 34,
          "totalTestcases": 65,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        # TODO: implement\n        pass",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_1",
          "startedAt": 1746878148000,
          "statusMsg": "Time Limit Exceeded",
          "totalCorrect": 59,
          "totalTestcases": 79,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        # TODO: add logic",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_2",
          "startedAt": 1746878220000,
          "statusMsg": "Runtime Error",
          "totalCorrect": 44,
          "totalTestcases": 72,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_3",
          "startedAt": 1746878291999,
          "statusMsg": "Wrong Answer",
          "totalCorrect": 30,
          "totalTestcases": 74,
          "runtimeError": null,
          "lastTestcase": "Sample test case that failed",
          "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        # Fix bounds check\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n        return -1",
          "compareResult": null,
          "runtime": null,
          "memory": null
        },
        {
          "id": "run_1758155029478_4",
          "startedAt": 1746878364000,
          "statusMsg": "Accepted",
          "totalCorrect": 69,
          "totalTestcases": 74,
          "runtimeError": null,
          "lastTestcase": null,
          "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n        \n        return -1",
          "compareResult": null,
          "runtime": 124,
          "memory": 18
        }
      ],
      "_window": {
        "startMs": 1746878040000,
        "endMs": 1746878400000
      }
    }
  },
  {
    "slug": "bus-routes",
    "title": "bus routes",
    "timestamp": 1747051200,
    "status": "Accepted",
    "lang": "python3",
    "timeUsed": 3308,
    "code": "\"\"\"\nOk, so i'm thinking for this problem that we'll probably want to use some kind of dfs. I don't think dykstras would\nbe helpful here cuz theres no lenths to worry about. What i'm confused about tho, is how to keep track of which bus\nwe're on. We can count the stops, but the actual bus is more difficult to know I thnk. Maybe what we could do is just\nhave a lookup for buses thats routes interact with a space. Then loop through first the possible buses to take from\nthat space, then the possible spaces to move to on that bus. We'll keep track of mem to avoid going in circles and\nkeep track of the number of times we switch buses. Ok. looking at the constrainsts I don't think this will work because\nwe have a very large amount of routes for each bus and up to 500 buses as well. I'm thinking it might be a better\nidea to use A* here since the space is large and we need the optimal path. Although, i'm not sure how to incorporate\nminimizing the buses and not just the stops. Ok, i'm thinking we can't use A* cuz theres no distance estimate. Maybe,\ninstead we could use dykstra and convert the problem space to a conventional graph. If we represent the graph as\nbuses and not stops we might be able to significantly reduce the problem space. For example, if we have\nroute 1: 1->2->3->4->5->1..\nroute 2: 5->6->7->8->9->5..\nstart 1, goal 9\nthen we really just have route 1 <-> route 2 graph and route 2 is our goal cuz it contains our goal node.\nso to convert our space I think we want to find every bus we can get on at every step. So first i'll index\nbuses by stops. Then we'll go through each of the buses stops and create an edge for every bus we can go\nto from the current bus. We'll repeat for every bus. Then I think we could just use bfs or else dykstras.\n\"\"\"\nclass Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        if source == target: return 0 # edge case, no buses\n\n        # index stops -> buses\n        stop_to_bus = defaultdict(set)\n        for bus, route in enumerate(routes):\n            for stop in route:\n                stop_to_bus[stop].add(bus)\n\n        # create the adj bus graph\n        bus_graph = defaultdict(set)\n        starts = set()\n        ends = set()\n        for bus, route in enumerate(routes):\n            for stop in route:\n                if stop == source: starts.add(bus)\n                if stop == target: ends.add(bus)\n                for other_bus in stop_to_bus[stop]:\n                    bus_graph[bus].add(other_bus)\n                    bus_graph[other_bus].add(bus)\n        \n        # navigate the bus graph\n        dist = 1\n        mem = set(starts)\n        q = deque(starts)\n        while q:\n            q_size = len(q)\n            for _ in range(q_size):\n                bus = q.popleft()\n                if bus in ends: return dist\n                for next_bus in bus_graph[bus]:\n                    if next_bus not in mem:\n                        q.append(next_bus)\n                        mem.add(next_bus)\n            dist+=1\n        return -1\n        \n\n            ",
    "submissionDetails": {
      "codeOutput": "",
      "compileError": null,
      "expectedOutput": "",
      "fullCodeOutput": null,
      "lastTestcase": "",
      "memory": 50868000,
      "memoryDisplay": "50.9 MB",
      "memoryPercentile": 28.610199999999985,
      "notes": "",
      "runtime": 3768,
      "runtimeDisplay": "3768 ms",
      "runtimeError": null,
      "runtimePercentile": 5.0056999999997025,
      "totalCorrect": 54,
      "totalTestcases": 54
    },
    "codingJourney": {
      "firstSnapshot": 1747047892483,
      "lastSnapshot": 1747051190374,
      "snapshotCount": 105,
      "snapshots": [
        {
          "checksumAfter": "1983380035",
          "checksumBefore": "10",
          "encodingInfo": "utf8 + nfc + lf",
          "fullCode": "class Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        \n",
          "isCheckpoint": true,
          "patchText": "@@ -1 +1,120 @@\n+class Solution:%0A    def numBusesToDestination(self, routes: List%5BList%5Bint%5D%5D, source: int, target: int) -%3E int:%0A        \n %0A\n",
          "timestamp": 1747047892483
        },
        {
          "checksumAfter": "-2077604077",
          "checksumBefore": "1983380035",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1,8 +1,16 @@\n+%22%22%22%0A%22%22%22%0A\n class So\n",
          "timestamp": 1747048121290
        },
        {
          "checksumAfter": "-1337492032",
          "checksumBefore": "-2077604077",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1,12 +1,45 @@\n %22%22%22%0A\n+Ok, so i'm thinking for this pro%0A\n %22%22%22%0Aclas\n",
          "timestamp": 1747048128289
        },
        {
          "checksumAfter": "-1415905942",
          "checksumBefore": "-1337492032",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -29,16 +29,49 @@\n this pro\n+blem that we'll probably want to \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048142293
        },
        {
          "checksumAfter": "993913879",
          "checksumBefore": "-1415905942",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -62,16 +62,50 @@\n want to \n+use some kind of dfs. I don't thin\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048191293
        },
        {
          "checksumAfter": "-950426036",
          "checksumBefore": "993913879",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -96,16 +96,47 @@\n n't thin\n+k dykstras would%0Abe helpful her\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048199291
        },
        {
          "checksumAfter": "244997142",
          "checksumBefore": "-950426036",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -127,16 +127,52 @@\n pful her\n+e cuz theres no lenths to worry abou\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048214291
        },
        {
          "checksumAfter": "666962214",
          "checksumBefore": "244997142",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -163,16 +163,46 @@\n rry abou\n+t. What i'm confused about tho\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048241307
        },
        {
          "checksumAfter": "-651697773",
          "checksumBefore": "666962214",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -193,16 +193,47 @@\n bout tho\n+, is how to keep track of which\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048249291
        },
        {
          "checksumAfter": "-1214711776",
          "checksumBefore": "-651697773",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -224,16 +224,48 @@\n of which\n+ bus%0Awe're on. We can count the \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048270291
        },
        {
          "checksumAfter": "1445856926",
          "checksumBefore": "-1214711776",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -256,16 +256,49 @@\n unt the \n+stops, but the actual bus is more\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048278291
        },
        {
          "checksumAfter": "-1110201432",
          "checksumBefore": "1445856926",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -289,16 +289,49 @@\n  is more\n+ difficult to know I thnk. Maybe \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048375292
        },
        {
          "checksumAfter": "1600808805",
          "checksumBefore": "-1110201432",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -322,16 +322,51 @@\n . Maybe \n+what we could do is just%0Ahave a loo\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048385299
        },
        {
          "checksumAfter": "2125725896",
          "checksumBefore": "1600808805",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -357,16 +357,48 @@\n ve a loo\n+kup for buses thats routes inter\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048422296
        },
        {
          "checksumAfter": "508642766",
          "checksumBefore": "2125725896",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -389,16 +389,46 @@\n es inter\n+act with a space. Then loop th\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048436304
        },
        {
          "checksumAfter": "2079032005",
          "checksumBefore": "508642766",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -419,16 +419,46 @@\n  loop th\n+rough first the possible busse\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048443292
        },
        {
          "checksumAfter": "375994999",
          "checksumBefore": "2079032005",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -447,18 +447,51 @@\n ible bus\n-s\n e\n+s to take from%0Athat space, then th\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048453292
        },
        {
          "checksumAfter": "-752387521",
          "checksumBefore": "375994999",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -482,16 +482,53 @@\n  then th\n+e possible spaces to move to on that \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048465293
        },
        {
          "checksumAfter": "1470938423",
          "checksumBefore": "-752387521",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -519,16 +519,48 @@\n on that \n+bus. We'll keep track of mem to \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048473292
        },
        {
          "checksumAfter": "-1918978730",
          "checksumBefore": "1470938423",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -551,16 +551,48 @@\n  mem to \n+avoid going in circles and%0Akeep \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048499295
        },
        {
          "checksumAfter": "1781181971",
          "checksumBefore": "-1918978730",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -583,16 +583,48 @@\n nd%0Akeep \n+track of the number of times we \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048506293
        },
        {
          "checksumAfter": "1531993658",
          "checksumBefore": "1781181971",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -615,16 +615,49 @@\n imes we \n+switch buses. Ok. looking at the \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048888323
        },
        {
          "checksumAfter": "275088242",
          "checksumBefore": "1531993658",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -648,16 +648,48 @@\n  at the \n+constrainsts I don't think this \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048894322
        },
        {
          "checksumAfter": "-981812743",
          "checksumBefore": "275088242",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -680,16 +680,46 @@\n nk this \n+will work because%0Awe have a ve\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048901320
        },
        {
          "checksumAfter": "148071482",
          "checksumBefore": "-981812743",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -710,16 +710,47 @@\n ave a ve\n+ry large amount of routes for e\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048913320
        },
        {
          "checksumAfter": "-1839492225",
          "checksumBefore": "148071482",
          "encodingInfo": "utf8 + nfc + lf",
          "fullCode": "\"\"\"\nOk, so i'm thinking for this problem that we'll probably want to use some kind of dfs. I don't think dykstras would\nbe helpful here cuz theres no lenths to worry about. What i'm confused about tho, is how to keep track of which bus\nwe're on. We can count the stops, but the actual bus is more difficult to know I thnk. Maybe what we could do is just\nhave a lookup for buses thats routes interact with a space. Then loop through first the possible buses to take from\nthat space, then the possible spaces to move to on that bus. We'll keep track of mem to avoid going in circles and\nkeep track of the number of times we switch buses. Ok. looking at the constrainsts I don't think this will work because\nwe have a very large amount of routes for each bus and up to 500 buses to\n\"\"\"\nclass Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        \n",
          "isCheckpoint": true,
          "patchText": "@@ -741,16 +741,46 @@\n es for e\n+ach bus and up to 500 buses to\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747048924323
        },
        {
          "checksumAfter": "290838087",
          "checksumBefore": "-1839492225",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -769,18 +769,46 @@\n 0 buses \n+as well. I'm thinking it migh\n t\n-o\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049033325
        },
        {
          "checksumAfter": "714530099",
          "checksumBefore": "290838087",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -799,16 +799,48 @@\n it might\n+ be a better%0Aidea to use A* here\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049041322
        },
        {
          "checksumAfter": "1857102846",
          "checksumBefore": "714530099",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -831,16 +831,46 @@\n  A* here\n+ since the space is large and \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049052326
        },
        {
          "checksumAfter": "-284053123",
          "checksumBefore": "1857102846",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -861,16 +861,48 @@\n rge and \n+we need the optimal path. Althou\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049075326
        },
        {
          "checksumAfter": "-887063090",
          "checksumBefore": "-284053123",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -893,16 +893,48 @@\n . Althou\n+gh, i'm not sure how to incorpor\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049082323
        },
        {
          "checksumAfter": "-2104718350",
          "checksumBefore": "-887063090",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -925,16 +925,48 @@\n incorpor\n+ate%0Aminimizing the buses and not\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049089321
        },
        {
          "checksumAfter": "-1826680573",
          "checksumBefore": "-2104718350",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -957,16 +957,50 @@\n  and not\n+ just the stops. Ok, i'm thinking \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049659343
        },
        {
          "checksumAfter": "-1433608396",
          "checksumBefore": "-1826680573",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -991,16 +991,46 @@\n hinking \n+we can't use A* cuz theres no \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049666348
        },
        {
          "checksumAfter": "-1219430291",
          "checksumBefore": "-1433608396",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1021,16 +1021,46 @@\n eres no \n+distance estimate. Maybe,%0Ainst\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049673352
        },
        {
          "checksumAfter": "-1742463705",
          "checksumBefore": "-1219430291",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1051,16 +1051,51 @@\n be,%0Ainst\n+ead we could use dykstra and conver\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049682348
        },
        {
          "checksumAfter": "-273017640",
          "checksumBefore": "-1742463705",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1086,16 +1086,50 @@\n d conver\n+t the problem space to a conventio\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049687343
        },
        {
          "checksumAfter": "1251656128",
          "checksumBefore": "-273017640",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1120,16 +1120,48 @@\n onventio\n+nal graph. If we represent the g\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049706348
        },
        {
          "checksumAfter": "-1899188751",
          "checksumBefore": "1251656128",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1152,16 +1152,50 @@\n nt the g\n+raph as%0Abuses and not stops we mig\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049715347
        },
        {
          "checksumAfter": "1889701059",
          "checksumBefore": "-1899188751",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1186,16 +1186,50 @@\n s we mig\n+ht be able to significantly reduce\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049721356
        },
        {
          "checksumAfter": "1240428476",
          "checksumBefore": "1889701059",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1220,16 +1220,47 @@\n y reduce\n+ the problem space. For example\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049729347
        },
        {
          "checksumAfter": "-1199425377",
          "checksumBefore": "1240428476",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1251,16 +1251,47 @@\n  example\n+, if we have%0Aroute 1: 1-%3E2-%3E1..\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049744348
        },
        {
          "checksumAfter": "1750037877",
          "checksumBefore": "-1199425377",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1283,11 +1283,42 @@\n %3E2-%3E\n-1..\n+3-%3E4-%3E5-%3E1..%0Aroute 2: 5-%3E6-%3E7-%3E8-%3E\n %0A%22%22%22\n",
          "timestamp": 1747049768346
        },
        {
          "checksumAfter": "621757039",
          "checksumBefore": "1750037877",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1313,16 +1313,27 @@\n -%3E7-%3E8-%3E\n+9-%3E5..%0A%0Athe\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049789345
        },
        {
          "checksumAfter": "-1555007439",
          "checksumBefore": "621757039",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1324,12 +1324,44 @@\n 5..%0A\n-%0Athe\n+start 1, goal 9%0Athen we really just \n %0A%22%22%22\n",
          "timestamp": 1747049801349
        },
        {
          "checksumAfter": "-1043815567",
          "checksumBefore": "-1555007439",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1356,16 +1356,47 @@\n ly just \n+have route 1 %3C-%3E route 2 graph \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049813349
        },
        {
          "checksumAfter": "-1800553651",
          "checksumBefore": "-1043815567",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1387,16 +1387,47 @@\n 2 graph \n+and route 2 is our goal cuz it \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049820349
        },
        {
          "checksumAfter": "-1238593334",
          "checksumBefore": "-1800553651",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1418,16 +1418,48 @@\n  cuz it \n+contains our goal node.%0Aso to co\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049840355
        },
        {
          "checksumAfter": "44833533",
          "checksumBefore": "-1238593334",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1450,16 +1450,50 @@\n so to co\n+nvert our space I think we want to\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049852346
        },
        {
          "checksumAfter": "-645442116",
          "checksumBefore": "44833533",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1484,16 +1484,46 @@\n  want to\n+ find every bus we can get on \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049868351
        },
        {
          "checksumAfter": "1351992010",
          "checksumBefore": "-645442116",
          "encodingInfo": "utf8 + nfc + lf",
          "fullCode": "\"\"\"\nOk, so i'm thinking for this problem that we'll probably want to use some kind of dfs. I don't think dykstras would\nbe helpful here cuz theres no lenths to worry about. What i'm confused about tho, is how to keep track of which bus\nwe're on. We can count the stops, but the actual bus is more difficult to know I thnk. Maybe what we could do is just\nhave a lookup for buses thats routes interact with a space. Then loop through first the possible buses to take from\nthat space, then the possible spaces to move to on that bus. We'll keep track of mem to avoid going in circles and\nkeep track of the number of times we switch buses. Ok. looking at the constrainsts I don't think this will work because\nwe have a very large amount of routes for each bus and up to 500 buses as well. I'm thinking it might be a better\nidea to use A* here since the space is large and we need the optimal path. Although, i'm not sure how to incorporate\nminimizing the buses and not just the stops. Ok, i'm thinking we can't use A* cuz theres no distance estimate. Maybe,\ninstead we could use dykstra and convert the problem space to a conventional graph. If we represent the graph as\nbuses and not stops we might be able to significantly reduce the problem space. For example, if we have\nroute 1: 1->2->3->4->5->1..\nroute 2: 5->6->7->8->9->5..\nstart 1, goal 9\nthen we really just have route 1 <-> route 2 graph and route 2 is our goal cuz it contains our goal node.\nso to convert our space I think we want to find every bus we can get on at every step. So first i'll inde\n\"\"\"\nclass Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        \n",
          "isCheckpoint": true,
          "patchText": "@@ -1514,16 +1514,49 @@\n  get on \n+at every step. So first i'll inde\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049876349
        },
        {
          "checksumAfter": "-462786390",
          "checksumBefore": "1351992010",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1547,16 +1547,50 @@\n 'll inde\n+x%0Abuses by stops. Then we'll go th\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049904351
        },
        {
          "checksumAfter": "-164329623",
          "checksumBefore": "-462786390",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1581,16 +1581,46 @@\n ll go th\n+rough each of the buses stops \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049909347
        },
        {
          "checksumAfter": "445344142",
          "checksumBefore": "-164329623",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1611,16 +1611,46 @@\n s stops \n+and create an edge for every b\n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049916363
        },
        {
          "checksumAfter": "1221787763",
          "checksumBefore": "445344142",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1641,16 +1641,49 @@\n  every b\n+us we can go%0Ato from the current \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049925350
        },
        {
          "checksumAfter": "-995005653",
          "checksumBefore": "1221787763",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1674,16 +1674,48 @@\n current \n+bus. We'll repeat for every bus \n %0A%22%22%22%0Acla\n",
          "timestamp": 1747049941348
        },
        {
          "checksumAfter": "1336789657",
          "checksumBefore": "-995005653",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1705,16 +1705,48 @@\n very bus\n+. Then I think we could just use\n  %0A%22%22%22%0Acl\n",
          "timestamp": 1747049952358
        },
        {
          "checksumAfter": "246613731",
          "checksumBefore": "1336789657",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1738,16 +1738,37 @@\n ust use \n+bfs or else dykstras.\n %0A%22%22%22%0Acla\n@@ -1883,9 +1883,22 @@\n         \n+# index stops\n %0A\n",
          "timestamp": 1747050054350
        },
        {
          "checksumAfter": "-1262494065",
          "checksumBefore": "246613731",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1896,9 +1896,40 @@\n ex stops\n+ -%3E buses%0A        for route in \n %0A\n",
          "timestamp": 1747050063353
        },
        {
          "checksumAfter": "525319567",
          "checksumBefore": "-1262494065",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1917,16 +1917,19 @@\n      for\n+ i,\n  route i\n@@ -1930,9 +1930,40 @@\n oute in \n+enumerate(routes):%0A            \n %0A\n",
          "timestamp": 1747050084353
        },
        {
          "checksumAfter": "1955364981",
          "checksumBefore": "525319567",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1906,16 +1906,25 @@\n %3E buses%0A\n+        %0A\n         \n@@ -1962,17 +1962,4 @@\n s):%0A\n-            %0A\n",
          "timestamp": 1747050088353
        },
        {
          "checksumAfter": "-925969801",
          "checksumBefore": "1955364981",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1914,16 +1914,46 @@\n         \n+stop_to_bus = defaultdict(set)\n %0A       \n",
          "timestamp": 1747050118351
        },
        {
          "checksumAfter": "492025678",
          "checksumBefore": "-925969801",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1988,8 +1988,39 @@\n outes):%0A\n+            for stop in route:%0A\n",
          "timestamp": 1747050134364
        },
        {
          "checksumAfter": "1918833533",
          "checksumBefore": "492025678",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2019,8 +2019,38 @@\n  route:%0A\n+                stop_to_bus%5B%5D%0A\n",
          "timestamp": 1747050154351
        },
        {
          "checksumAfter": "279465614",
          "checksumBefore": "1918833533",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1957,17 +1957,19 @@\n     for \n-i\n+bus\n , route \n@@ -2049,10 +2049,37 @@\n _to_bus%5B\n-%5D\n+stop%5D.add(bus)%0A%0A            \n %0A\n",
          "timestamp": 1747050190355
        },
        {
          "checksumAfter": "-564227397",
          "checksumBefore": "279465614",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2065,21 +2065,52 @@\n d(bus)%0A%0A    \n+    # create the adj bus graph%0A\n         %0A\n",
          "timestamp": 1747050210355
        },
        {
          "checksumAfter": "1054837459",
          "checksumBefore": "-564227397",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2108,9 +2108,47 @@\n         \n+bus_graph = defaultdict(set)%0A        f\n %0A\n",
          "timestamp": 1747050228352
        },
        {
          "checksumAfter": "1500470021",
          "checksumBefore": "1054837459",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2146,9 +2146,43 @@\n        f\n+or bus, route in enumerate(routes)\n %0A\n",
          "timestamp": 1747050237352
        },
        {
          "checksumAfter": "2058270501",
          "checksumBefore": "1500470021",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2180,9 +2180,39 @@\n (routes)\n+:%0A            for stop in rout\n %0A\n",
          "timestamp": 1747050253352
        },
        {
          "checksumAfter": "1497106806",
          "checksumBefore": "2058270501",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2210,9 +2210,39 @@\n  in rout\n+e:%0A                for bus in \n %0A\n",
          "timestamp": 1747050280356
        },
        {
          "checksumAfter": "-1516539915",
          "checksumBefore": "1497106806",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2240,9 +2240,48 @@\n  bus in \n+stop_to_bus%5Bstop%5D:%0A                    \n %0A\n",
          "timestamp": 1747050292357
        },
        {
          "checksumAfter": "1425455337",
          "checksumBefore": "-1516539915",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2233,16 +2233,22 @@\n     for \n+other_\n bus in s\n@@ -2285,9 +2285,34 @@\n         \n+bus_graph%5Bbus%5D.add(other)\n %0A\n",
          "timestamp": 1747050323353
        },
        {
          "checksumAfter": "178974725",
          "checksumBefore": "1425455337",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2309,10 +2309,44 @@\n dd(other\n-)\n+_bus)%0A                    bus_graph\n %0A\n",
          "timestamp": 1747050329358
        },
        {
          "checksumAfter": "1017698631",
          "checksumBefore": "178974725",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2340,13 +2340,51 @@\n    bus_graph\n+%5Bother_bus%5D.add%5Bbus%5D%0A        %0A        \n %0A\n",
          "timestamp": 1747050341358
        },
        {
          "checksumAfter": "-1186216783",
          "checksumBefore": "1017698631",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2129,32 +2129,47 @@\n efaultdict(set)%0A\n+        starts%0A\n         for bus,\n@@ -2389,17 +2389,32 @@\n        %0A        \n+# navigate the \n %0A\n",
          "timestamp": 1747050373358
        },
        {
          "checksumAfter": "852715570",
          "checksumBefore": "-1186216783",
          "encodingInfo": "utf8 + nfc + lf",
          "fullCode": "\"\"\"\nOk, so i'm thinking for this problem that we'll probably want to use some kind of dfs. I don't think dykstras would\nbe helpful here cuz theres no lenths to worry about. What i'm confused about tho, is how to keep track of which bus\nwe're on. We can count the stops, but the actual bus is more difficult to know I thnk. Maybe what we could do is just\nhave a lookup for buses thats routes interact with a space. Then loop through first the possible buses to take from\nthat space, then the possible spaces to move to on that bus. We'll keep track of mem to avoid going in circles and\nkeep track of the number of times we switch buses. Ok. looking at the constrainsts I don't think this will work because\nwe have a very large amount of routes for each bus and up to 500 buses as well. I'm thinking it might be a better\nidea to use A* here since the space is large and we need the optimal path. Although, i'm not sure how to incorporate\nminimizing the buses and not just the stops. Ok, i'm thinking we can't use A* cuz theres no distance estimate. Maybe,\ninstead we could use dykstra and convert the problem space to a conventional graph. If we represent the graph as\nbuses and not stops we might be able to significantly reduce the problem space. For example, if we have\nroute 1: 1->2->3->4->5->1..\nroute 2: 5->6->7->8->9->5..\nstart 1, goal 9\nthen we really just have route 1 <-> route 2 graph and route 2 is our goal cuz it contains our goal node.\nso to convert our space I think we want to find every bus we can get on at every step. So first i'll index\nbuses by stops. Then we'll go through each of the buses stops and create an edge for every bus we can go\nto from the current bus. We'll repeat for every bus. Then I think we could just use bfs or else dykstras.\n\"\"\"\nclass Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        # index stops -> buses\n        stop_to_bus = defaultdict(set)\n        for bus, route in enumerate(routes):\n            for stop in route:\n                stop_to_bus[stop].add(bus)\n\n        # create the adj bus graph\n        bus_graph = defaultdict(set)\n        starts = []\n        ends = []\n        for bus, route in enumerate(routes):\n            for stop in route:\n                if\n                for other_bus in stop_to_bus[stop]:\n                    bus_graph[bus].add(other_bus)\n                    bus_graph[other_bus].add[bus]\n        \n        # navigate the \n",
          "isCheckpoint": true,
          "patchText": "@@ -2151,16 +2151,39 @@\n   starts\n+ = %5B%5D%0A        ends = %5B%5D\n %0A       \n@@ -2243,32 +2243,51 @@\n  stop in route:%0A\n+                if%0A\n                 \n",
          "timestamp": 1747050393358
        },
        {
          "checksumAfter": "1282082165",
          "checksumBefore": "852715570",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2150,26 +2150,29 @@\n    starts = \n-%5B%5D\n+set()\n %0A        end\n@@ -2179,10 +2179,13 @@\n s = \n-%5B%5D\n+set()\n %0A   \n@@ -2275,16 +2275,32 @@\n       if\n+ stop == source:\n %0A       \n",
          "timestamp": 1747050416357
        },
        {
          "checksumAfter": "-1098119063",
          "checksumBefore": "1282082165",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2291,16 +2291,51 @@\n  source:\n+ starts.add(bus)%0A                if\n %0A       \n",
          "timestamp": 1747050431355
        },
        {
          "checksumAfter": "-190821738",
          "checksumBefore": "-1098119063",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2326,16 +2326,46 @@\n       if\n+ stop == target: ends.add(bus)\n %0A       \n",
          "timestamp": 1747050446355
        },
        {
          "checksumAfter": "408297833",
          "checksumBefore": "-190821738",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2542,8 +2542,40 @@\n te the %0A\n+            for start in starts%0A\n",
          "timestamp": 1747050461359
        },
        {
          "checksumAfter": "1153786233",
          "checksumBefore": "408297833",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2541,21 +2541,21 @@\n ate the \n-%0A    \n+bus %0A\n         \n@@ -2573,9 +2573,23 @@\n n starts\n+:%0A            \n %0A\n",
          "timestamp": 1747050471356
        },
        {
          "checksumAfter": "-825166590",
          "checksumBefore": "1153786233",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2545,16 +2545,47 @@\n the bus \n+graph%0A        best = math.inf()\n %0A       \n",
          "timestamp": 1747050509359
        },
        {
          "checksumAfter": "34597479",
          "checksumBefore": "-825166590",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2574,18 +2574,16 @@\n math.inf\n-()\n %0A       \n@@ -2604,16 +2604,49 @@\n starts:%0A\n+            # perform bfs for ea%0A\n         \n",
          "timestamp": 1747050543360
        },
        {
          "checksumAfter": "870546279",
          "checksumBefore": "34597479",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2636,16 +2636,47 @@\n s for ea\n+ch possible starting bus until \n %0A       \n",
          "timestamp": 1747050552360
        },
        {
          "checksumAfter": "-2033528162",
          "checksumBefore": "870546279",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2667,16 +2667,46 @@\n s until \n+we reach the closest ending bu\n %0A       \n",
          "timestamp": 1747050559357
        },
        {
          "checksumAfter": "-679336758",
          "checksumBefore": "-2033528162",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2697,16 +2697,54 @@\n nding bu\n+s%0A            mem = set()%0A            \n %0A       \n",
          "timestamp": 1747050630361
        },
        {
          "checksumAfter": "330745971",
          "checksumBefore": "-679336758",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2620,95 +2620,9 @@\n     \n-# perform bfs for each possible starting bus until we reach the closest ending bus%0A    \n+%0A\n     \n@@ -2637,34 +2637,42 @@\n = set()%0A        \n-    \n+q = deque()%0A\n %0A            %0A\n",
          "timestamp": 1747050685363
        },
        {
          "checksumAfter": "-1205490950",
          "checksumBefore": "330745971",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2587,41 +2587,8 @@\n     \n-for start in starts:%0A            \n %0A   \n",
          "timestamp": 1747050689363
        },
        {
          "checksumAfter": "1227807913",
          "checksumBefore": "-1205490950",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2575,25 +2575,16 @@\n ath.inf%0A\n-        %0A\n         \n@@ -2614,16 +2614,26 @@\n  deque()\n+%0A        q\n %0A%0A      \n",
          "timestamp": 1747050693359
        },
        {
          "checksumAfter": "297333071",
          "checksumBefore": "1227807913",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2563,23 +2563,16 @@\n     \n-be\n+di\n st = \n-math.inf\n+0\n %0A   \n@@ -2606,16 +2606,22 @@\n = deque(\n+starts\n )%0A      \n@@ -2622,17 +2622,26 @@\n         \n-q\n+w%0A        \n %0A%0A      \n",
          "timestamp": 1747050758360
        },
        {
          "checksumAfter": "-1736569828",
          "checksumBefore": "297333071",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2582,24 +2582,30 @@\n   mem = set(\n+starts\n )%0A        q \n@@ -2629,16 +2629,42 @@\n        w\n+hile q:%0A            bus = \n %0A       \n",
          "timestamp": 1747050825362
        },
        {
          "checksumAfter": "-744551806",
          "checksumBefore": "-1736569828",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2655,16 +2655,50 @@\n   bus = \n+q.popleft()%0A            if bus in \n %0A       \n",
          "timestamp": 1747050833363
        },
        {
          "checksumAfter": "1996384830",
          "checksumBefore": "-744551806",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2637,16 +2637,29 @@\n hile q:%0A\n+            %0A\n         \n@@ -2702,16 +2702,33 @@\n  bus in \n+ends: return dist\n %0A       \n",
          "timestamp": 1747050852368
        },
        {
          "checksumAfter": "619444398",
          "checksumBefore": "1996384830",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2641,32 +2641,64 @@\n  q:%0A            \n+len%0A            for _ in range()\n %0A            bus\n",
          "timestamp": 1747050872367
        },
        {
          "checksumAfter": "287160597",
          "checksumBefore": "619444398",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2649,19 +2649,31 @@\n         \n-len\n+q_size = len(q)\n %0A       \n@@ -2692,18 +2692,26 @@\n n range(\n-)%0A\n+q_size)%0A  \n         \n@@ -2714,16 +2714,18 @@\n         \n+  \n bus = q.\n@@ -2730,24 +2730,28 @@\n q.popleft()%0A\n+    \n             \n@@ -2778,16 +2778,29 @@\n rn dist%0A\n+            %0A\n         \n",
          "timestamp": 1747050899367
        },
        {
          "checksumAfter": "175892239",
          "checksumBefore": "287160597",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2782,32 +2782,65 @@\n ist%0A            \n+    for next_%0A            dist+=1\n %0A        %0A%0A     \n",
          "timestamp": 1747050923364
        },
        {
          "checksumAfter": "2124774558",
          "checksumBefore": "175892239",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2803,16 +2803,62 @@\n or next_\n+bus in bus_graph%5Bbus%5D:%0A                    if \n %0A       \n",
          "timestamp": 1747050938362
        },
        {
          "checksumAfter": "-705719581",
          "checksumBefore": "2124774558",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2849,16 +2849,61 @@\n      if \n+next_bus not in mem:%0A                        \n %0A       \n",
          "timestamp": 1747050944367
        },
        {
          "checksumAfter": "365125578",
          "checksumBefore": "-705719581",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2886,32 +2886,76 @@\n                 \n+q.append(next_bus)%0A                        m\n %0A            dis\n",
          "timestamp": 1747050973363
        },
        {
          "checksumAfter": "471632984",
          "checksumBefore": "365125578",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2938,16 +2938,32 @@\n        m\n+em.add(next_bus)\n %0A       \n@@ -2975,16 +2975,32 @@\n dist+=1%0A\n+        return %0A\n         \n",
          "timestamp": 1747050995367
        },
        {
          "checksumAfter": "-1347757526",
          "checksumBefore": "471632984",
          "encodingInfo": "utf8 + nfc + lf",
          "fullCode": "\"\"\"\nOk, so i'm thinking for this problem that we'll probably want to use some kind of dfs. I don't think dykstras would\nbe helpful here cuz theres no lenths to worry about. What i'm confused about tho, is how to keep track of which bus\nwe're on. We can count the stops, but the actual bus is more difficult to know I thnk. Maybe what we could do is just\nhave a lookup for buses thats routes interact with a space. Then loop through first the possible buses to take from\nthat space, then the possible spaces to move to on that bus. We'll keep track of mem to avoid going in circles and\nkeep track of the number of times we switch buses. Ok. looking at the constrainsts I don't think this will work because\nwe have a very large amount of routes for each bus and up to 500 buses as well. I'm thinking it might be a better\nidea to use A* here since the space is large and we need the optimal path. Although, i'm not sure how to incorporate\nminimizing the buses and not just the stops. Ok, i'm thinking we can't use A* cuz theres no distance estimate. Maybe,\ninstead we could use dykstra and convert the problem space to a conventional graph. If we represent the graph as\nbuses and not stops we might be able to significantly reduce the problem space. For example, if we have\nroute 1: 1->2->3->4->5->1..\nroute 2: 5->6->7->8->9->5..\nstart 1, goal 9\nthen we really just have route 1 <-> route 2 graph and route 2 is our goal cuz it contains our goal node.\nso to convert our space I think we want to find every bus we can get on at every step. So first i'll index\nbuses by stops. Then we'll go through each of the buses stops and create an edge for every bus we can go\nto from the current bus. We'll repeat for every bus. Then I think we could just use bfs or else dykstras.\n\"\"\"\nclass Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        # index stops -> buses\n        stop_to_bus = defaultdict(set)\n        for bus, route in enumerate(routes):\n            for stop in route:\n                stop_to_bus[stop].add(bus)\n\n        # create the adj bus graph\n        bus_graph = defaultdict(set)\n        starts = set()\n        ends = set()\n        for bus, route in enumerate(routes):\n            for stop in route:\n                if stop == source: starts.add(bus)\n                if stop == target: ends.add(bus)\n                for other_bus in stop_to_bus[stop]:\n                    bus_graph[bus].add(other_bus)\n                    bus_graph[other_bus].add(bus)\n\n                    \n        \n        # navigate the bus graph\n        dist = 1\n        mem = set(starts)\n        q = deque(starts)\n        while q:\n            q_size = len(q)\n            for _ in range(q_size):\n                bus = q.popleft()\n                if bus in ends: return dist\n                for next_bus in bus_graph[bus]:\n                    if next_bus not in mem:\n                        q.append(next_bus)\n                        mem.add(next_bus)\n            dist+=1\n        return -1\n        \n\n            \n",
          "isCheckpoint": true,
          "patchText": "@@ -2503,21 +2503,43 @@\n bus%5D.add\n-%5B\n+(\n bus\n-%5D\n+)%0A%0A                    \n %0A       \n@@ -2588,17 +2588,17 @@\n  dist = \n-0\n+1\n %0A       \n@@ -2721,16 +2721,17 @@\n (q_size)\n+:\n %0A       \n@@ -3013,16 +3013,18 @@\n  return \n+-1\n %0A       \n",
          "timestamp": 1747051171367
        },
        {
          "checksumAfter": "-731481366",
          "checksumBefore": "-1347757526",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -2512,30 +2512,8 @@\n bus)\n-%0A%0A                    \n %0A   \n",
          "timestamp": 1747051175365
        },
        {
          "checksumAfter": "399266666",
          "checksumBefore": "-731481366",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1874,16 +1874,26 @@\n  -%3E int:\n+%0A%0A        \n %0A       \n",
          "timestamp": 1747051178365
        },
        {
          "checksumAfter": "432507242",
          "checksumBefore": "399266666",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1875,17 +1875,16 @@\n -%3E int:%0A\n-%0A\n         \n@@ -1876,32 +1876,33 @@\n %3E int:%0A        %0A\n+%0A\n         # index \n",
          "timestamp": 1747051179365
        },
        {
          "checksumAfter": "-1227521180",
          "checksumBefore": "432507242",
          "encodingInfo": "utf8 + nfc + lf",
          "patchText": "@@ -1875,32 +1875,63 @@\n -%3E int:%0A        \n+if source == target: return 0 #\n %0A%0A        # inde\n",
          "timestamp": 1747051190374
        }
      ],
      "totalCodingTime": 3297891,
      "hasDetailedJourney": true
    },
    "runEvents": {
      "_window": {
        "endMs": 1747051200000,
        "startMs": 1747047892000
      },
      "count": 5,
      "firstRun": 1747051028514,
      "hasDetailedRuns": true,
      "lastRun": 1747051120307,
      "runs": [
        {
          "code": "\"\"\"\nOk, so i'm thinking for this problem that we'll probably want to use some kind of dfs. I don't think dykstras would\nbe helpful here cuz theres no lenths to worry about. What i'm confused about tho, is how to keep track of which bus\nwe're on. We can count the stops, but the actual bus is more difficult to know I thnk. Maybe what we could do is just\nhave a lookup for buses thats routes interact with a space. Then loop through first the possible buses to take from\nthat space, then the possible spaces to move to on that bus. We'll keep track of mem to avoid going in circles and\nkeep track of the number of times we switch buses. Ok. looking at the constrainsts I don't think this will work because\nwe have a very large amount of routes for each bus and up to 500 buses as well. I'm thinking it might be a better\nidea to use A* here since the space is large and we need the optimal path. Although, i'm not sure how to incorporate\nminimizing the buses and not just the stops. Ok, i'm thinking we can't use A* cuz theres no distance estimate. Maybe,\ninstead we could use dykstra and convert the problem space to a conventional graph. If we represent the graph as\nbuses and not stops we might be able to significantly reduce the problem space. For example, if we have\nroute 1: 1->2->3->4->5->1..\nroute 2: 5->6->7->8->9->5..\nstart 1, goal 9\nthen we really just have route 1 <-> route 2 graph and route 2 is our goal cuz it contains our goal node.\nso to convert our space I think we want to find every bus we can get on at every step. So first i'll index\nbuses by stops. Then we'll go through each of the buses stops and create an edge for every bus we can go\nto from the current bus. We'll repeat for every bus. Then I think we could just use bfs or else dykstras.\n\"\"\"\nclass Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        # index stops -> buses\n        stop_to_bus = defaultdict(set)\n        for bus, route in enumerate(routes):\n            for stop in route:\n                stop_to_bus[stop].add(bus)\n\n        # create the adj bus graph\n        bus_graph = defaultdict(set)\n        starts = set()\n        ends = set()\n        for bus, route in enumerate(routes):\n            for stop in route:\n                if stop == source: starts.add(bus)\n                if stop == target: ends.add(bus)\n                for other_bus in stop_to_bus[stop]:\n                    bus_graph[bus].add(other_bus)\n                    bus_graph[other_bus].add[bus]\n        \n        # navigate the bus graph\n        dist = 0\n        mem = set(starts)\n        q = deque(starts)\n        while q:\n            q_size = len(q)\n            for _ in range(q_size)\n                bus = q.popleft()\n                if bus in ends: return dist\n                for next_bus in bus_graph[bus]:\n                    if next_bus not in mem:\n                        q.append(next_bus)\n                        mem.add(next_bus)\n            dist+=1\n        return -1\n        \n\n            ",
          "compareResult": "00",
          "id": "djmiska25_bus-routes_1765755525501",
          "lastTestcase": null,
          "memory": "N/A",
          "runtime": "N/A",
          "runtimeError": "Line 47: SyntaxError: expected ':'",
          "startedAt": 1747051028514,
          "statusMsg": "Runtime Error",
          "totalCorrect": 0,
          "totalTestcases": 2
        },
        {
          "code": "\"\"\"\nOk, so i'm thinking for this problem that we'll probably want to use some kind of dfs. I don't think dykstras would\nbe helpful here cuz theres no lenths to worry about. What i'm confused about tho, is how to keep track of which bus\nwe're on. We can count the stops, but the actual bus is more difficult to know I thnk. Maybe what we could do is just\nhave a lookup for buses thats routes interact with a space. Then loop through first the possible buses to take from\nthat space, then the possible spaces to move to on that bus. We'll keep track of mem to avoid going in circles and\nkeep track of the number of times we switch buses. Ok. looking at the constrainsts I don't think this will work because\nwe have a very large amount of routes for each bus and up to 500 buses as well. I'm thinking it might be a better\nidea to use A* here since the space is large and we need the optimal path. Although, i'm not sure how to incorporate\nminimizing the buses and not just the stops. Ok, i'm thinking we can't use A* cuz theres no distance estimate. Maybe,\ninstead we could use dykstra and convert the problem space to a conventional graph. If we represent the graph as\nbuses and not stops we might be able to significantly reduce the problem space. For example, if we have\nroute 1: 1->2->3->4->5->1..\nroute 2: 5->6->7->8->9->5..\nstart 1, goal 9\nthen we really just have route 1 <-> route 2 graph and route 2 is our goal cuz it contains our goal node.\nso to convert our space I think we want to find every bus we can get on at every step. So first i'll index\nbuses by stops. Then we'll go through each of the buses stops and create an edge for every bus we can go\nto from the current bus. We'll repeat for every bus. Then I think we could just use bfs or else dykstras.\n\"\"\"\nclass Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        # index stops -> buses\n        stop_to_bus = defaultdict(set)\n        for bus, route in enumerate(routes):\n            for stop in route:\n                stop_to_bus[stop].add(bus)\n\n        # create the adj bus graph\n        bus_graph = defaultdict(set)\n        starts = set()\n        ends = set()\n        for bus, route in enumerate(routes):\n            for stop in route:\n                if stop == source: starts.add(bus)\n                if stop == target: ends.add(bus)\n                for other_bus in stop_to_bus[stop]:\n                    bus_graph[bus].add(other_bus)\n                    bus_graph[other_bus].add[bus]\n        \n        # navigate the bus graph\n        dist = 0\n        mem = set(starts)\n        q = deque(starts)\n        while q:\n            q_size = len(q)\n            for _ in range(q_size):\n                bus = q.popleft()\n                if bus in ends: return dist\n                for next_bus in bus_graph[bus]:\n                    if next_bus not in mem:\n                        q.append(next_bus)\n                        mem.add(next_bus)\n            dist+=1\n        return -1\n        \n\n            ",
          "compareResult": "00",
          "id": "djmiska25_bus-routes_1765755542102",
          "lastTestcase": null,
          "memory": "N/A",
          "runtime": "N/A",
          "runtimeError": "Line 39: TypeError: 'builtin_function_or_method' object is not subscriptable",
          "startedAt": 1747051046093,
          "statusMsg": "Runtime Error",
          "totalCorrect": 0,
          "totalTestcases": 2
        },
        {
          "code": "\"\"\"\nOk, so i'm thinking for this problem that we'll probably want to use some kind of dfs. I don't think dykstras would\nbe helpful here cuz theres no lenths to worry about. What i'm confused about tho, is how to keep track of which bus\nwe're on. We can count the stops, but the actual bus is more difficult to know I thnk. Maybe what we could do is just\nhave a lookup for buses thats routes interact with a space. Then loop through first the possible buses to take from\nthat space, then the possible spaces to move to on that bus. We'll keep track of mem to avoid going in circles and\nkeep track of the number of times we switch buses. Ok. looking at the constrainsts I don't think this will work because\nwe have a very large amount of routes for each bus and up to 500 buses as well. I'm thinking it might be a better\nidea to use A* here since the space is large and we need the optimal path. Although, i'm not sure how to incorporate\nminimizing the buses and not just the stops. Ok, i'm thinking we can't use A* cuz theres no distance estimate. Maybe,\ninstead we could use dykstra and convert the problem space to a conventional graph. If we represent the graph as\nbuses and not stops we might be able to significantly reduce the problem space. For example, if we have\nroute 1: 1->2->3->4->5->1..\nroute 2: 5->6->7->8->9->5..\nstart 1, goal 9\nthen we really just have route 1 <-> route 2 graph and route 2 is our goal cuz it contains our goal node.\nso to convert our space I think we want to find every bus we can get on at every step. So first i'll index\nbuses by stops. Then we'll go through each of the buses stops and create an edge for every bus we can go\nto from the current bus. We'll repeat for every bus. Then I think we could just use bfs or else dykstras.\n\"\"\"\nclass Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        # index stops -> buses\n        stop_to_bus = defaultdict(set)\n        for bus, route in enumerate(routes):\n            for stop in route:\n                stop_to_bus[stop].add(bus)\n\n        # create the adj bus graph\n        bus_graph = defaultdict(set)\n        starts = set()\n        ends = set()\n        for bus, route in enumerate(routes):\n            for stop in route:\n                if stop == source: starts.add(bus)\n                if stop == target: ends.add(bus)\n                for other_bus in stop_to_bus[stop]:\n                    bus_graph[bus].add(other_bus)\n                    bus_graph[other_bus].add(bus)\n        \n        # navigate the bus graph\n        dist = 0\n        mem = set(starts)\n        q = deque(starts)\n        while q:\n            q_size = len(q)\n            for _ in range(q_size):\n                bus = q.popleft()\n                if bus in ends: return dist\n                for next_bus in bus_graph[bus]:\n                    if next_bus not in mem:\n                        q.append(next_bus)\n                        mem.add(next_bus)\n            dist+=1\n        return -1\n        \n\n            ",
          "compareResult": "01",
          "id": "djmiska25_bus-routes_1765755580289",
          "lastTestcase": null,
          "memory": "17.9 MB",
          "runtime": "0 ms",
          "runtimeError": null,
          "startedAt": 1747051084586,
          "statusMsg": "Accepted",
          "totalCorrect": 1,
          "totalTestcases": 2
        },
        {
          "code": "\"\"\"\nOk, so i'm thinking for this problem that we'll probably want to use some kind of dfs. I don't think dykstras would\nbe helpful here cuz theres no lenths to worry about. What i'm confused about tho, is how to keep track of which bus\nwe're on. We can count the stops, but the actual bus is more difficult to know I thnk. Maybe what we could do is just\nhave a lookup for buses thats routes interact with a space. Then loop through first the possible buses to take from\nthat space, then the possible spaces to move to on that bus. We'll keep track of mem to avoid going in circles and\nkeep track of the number of times we switch buses. Ok. looking at the constrainsts I don't think this will work because\nwe have a very large amount of routes for each bus and up to 500 buses as well. I'm thinking it might be a better\nidea to use A* here since the space is large and we need the optimal path. Although, i'm not sure how to incorporate\nminimizing the buses and not just the stops. Ok, i'm thinking we can't use A* cuz theres no distance estimate. Maybe,\ninstead we could use dykstra and convert the problem space to a conventional graph. If we represent the graph as\nbuses and not stops we might be able to significantly reduce the problem space. For example, if we have\nroute 1: 1->2->3->4->5->1..\nroute 2: 5->6->7->8->9->5..\nstart 1, goal 9\nthen we really just have route 1 <-> route 2 graph and route 2 is our goal cuz it contains our goal node.\nso to convert our space I think we want to find every bus we can get on at every step. So first i'll index\nbuses by stops. Then we'll go through each of the buses stops and create an edge for every bus we can go\nto from the current bus. We'll repeat for every bus. Then I think we could just use bfs or else dykstras.\n\"\"\"\nclass Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        # index stops -> buses\n        stop_to_bus = defaultdict(set)\n        for bus, route in enumerate(routes):\n            for stop in route:\n                stop_to_bus[stop].add(bus)\n\n        # create the adj bus graph\n        bus_graph = defaultdict(set)\n        starts = set()\n        ends = set()\n        for bus, route in enumerate(routes):\n            for stop in route:\n                if stop == source: starts.add(bus)\n                if stop == target: ends.add(bus)\n                for other_bus in stop_to_bus[stop]:\n                    bus_graph[bus].add(other_bus)\n                    bus_graph[other_bus].add(bus)\n        \n        # navigate the bus graph\n        dist = 1\n        mem = set(starts)\n        q = deque(starts)\n        while q:\n            q_size = len(q)\n            for _ in range(q_size):\n                bus = q.popleft()\n                if bus in ends: return dist\n                for next_bus in bus_graph[bus]:\n                    if next_bus not in mem:\n                        q.append(next_bus)\n                        mem.add(next_bus)\n            dist+=1\n        return -1\n        \n\n            ",
          "compareResult": "11",
          "id": "djmiska25_bus-routes_1765755610058",
          "lastTestcase": null,
          "memory": "17.8 MB",
          "runtime": "0 ms",
          "runtimeError": null,
          "startedAt": 1747051114774,
          "statusMsg": "Accepted",
          "totalCorrect": 2,
          "totalTestcases": 2
        },
        {
          "code": "\"\"\"\nOk, so i'm thinking for this problem that we'll probably want to use some kind of dfs. I don't think dykstras would\nbe helpful here cuz theres no lenths to worry about. What i'm confused about tho, is how to keep track of which bus\nwe're on. We can count the stops, but the actual bus is more difficult to know I thnk. Maybe what we could do is just\nhave a lookup for buses thats routes interact with a space. Then loop through first the possible buses to take from\nthat space, then the possible spaces to move to on that bus. We'll keep track of mem to avoid going in circles and\nkeep track of the number of times we switch buses. Ok. looking at the constrainsts I don't think this will work because\nwe have a very large amount of routes for each bus and up to 500 buses as well. I'm thinking it might be a better\nidea to use A* here since the space is large and we need the optimal path. Although, i'm not sure how to incorporate\nminimizing the buses and not just the stops. Ok, i'm thinking we can't use A* cuz theres no distance estimate. Maybe,\ninstead we could use dykstra and convert the problem space to a conventional graph. If we represent the graph as\nbuses and not stops we might be able to significantly reduce the problem space. For example, if we have\nroute 1: 1->2->3->4->5->1..\nroute 2: 5->6->7->8->9->5..\nstart 1, goal 9\nthen we really just have route 1 <-> route 2 graph and route 2 is our goal cuz it contains our goal node.\nso to convert our space I think we want to find every bus we can get on at every step. So first i'll index\nbuses by stops. Then we'll go through each of the buses stops and create an edge for every bus we can go\nto from the current bus. We'll repeat for every bus. Then I think we could just use bfs or else dykstras.\n\"\"\"\nclass Solution:\n    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        # index stops -> buses\n        stop_to_bus = defaultdict(set)\n        for bus, route in enumerate(routes):\n            for stop in route:\n                stop_to_bus[stop].add(bus)\n\n        # create the adj bus graph\n        bus_graph = defaultdict(set)\n        starts = set()\n        ends = set()\n        for bus, route in enumerate(routes):\n            for stop in route:\n                if stop == source: starts.add(bus)\n                if stop == target: ends.add(bus)\n                for other_bus in stop_to_bus[stop]:\n                    bus_graph[bus].add(other_bus)\n                    bus_graph[other_bus].add(bus)\n        \n        # navigate the bus graph\n        dist = 1\n        mem = set(starts)\n        q = deque(starts)\n        while q:\n            q_size = len(q)\n            for _ in range(q_size):\n                bus = q.popleft()\n                if bus in ends: return dist\n                for next_bus in bus_graph[bus]:\n                    if next_bus not in mem:\n                        q.append(next_bus)\n                        mem.add(next_bus)\n            dist+=1\n        return -1\n        \n\n            ",
          "compareResult": "111111111110101111011111111111111111111111111111111110",
          "id": "djmiska25_bus-routes_1765755620501",
          "lastTestcase": "[[1,7],[3,5]]\n5\n5",
          "memory": "N/A",
          "runtime": "N/A",
          "runtimeError": null,
          "startedAt": 1747051120307,
          "statusMsg": "Wrong Answer",
          "totalCorrect": 50,
          "totalTestcases": 54
        }
      ]
    },
    "usedHints": "none",
    "feedback": {
      "performance": {
        "time_to_solve": 3,
        "time_complexity": "3: O(totalStops + overlaps)",
        "space_complexity": "3: O(totalStops + busEdges)",
        "comments": "Good pivot to \u201cbuses as nodes\u201d + BFS for fewest transfers. Biggest speed win: don\u2019t build full bus-to-bus adjacency; expand neighbors on-the-fly via stop_to_bus and mark/clear stops so each stop is processed once."
      },
      "code_quality": {
        "readability": 3,
        "correctness": 5,
        "maintainability": 3,
        "comments": "Correct and passes all cases, including fixing source==target. Readability would improve by removing the long brainstorming docstring and tightening comments. Maintainability/perf improve by eliminating bus_graph and doing BFS expansions through stop_to_bus with visited stops."
      },
      "summary": {
        "final_score": 70,
        "comments": "Accepted hard BFS solution with solid modeling; minor thrash and a few run errors. Main issue is performance overhead from materializing dense bus_graph; switch to stop-driven BFS expansions to reach near-linear behavior in totalStops."
      }
    }
  }
]
